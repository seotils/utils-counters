# Счетчики и генераторы уникальных значений.

[English version] (README.md)

## Описание

Пакет реализует несколько счетчиков и один генератор уникальных значений,
которые вы можете использовать "из коробки".

Так же, есть возможность реализации собственных счетчиков и генераторов.

## License

Пакет распространяется под лицензией [GPL-3.0] (https://www.gnu.org/licenses/gpl-3.0.en.html).

## Установка

```bash

    composer require seotils/utils-counters

```

## Счетчики

Все счетчики реализуют интерфейс *Seotils\Utilites\Counters\Interfaces\ICounter*
и происходят от одного абстрактного базового класса *Seotils\Utilites\Counters\BaseCounter*.

Все счетчики работают только с целыми числами.

Все счетчики работают через механизм транзакций и могут быть возвращены к первичному состоянию.

### Интерфейс Seotils\Utilites\Counters\Interfaces\ICounter

1. *public function commit()*.

    Завершает транзакцию и сохраняет текущее значение счетчика в хранилище.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.

2. *public function generate( int $baseValue )*.

    В режиме транзакции генерирует новое значение счетчика.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.

    * *$baseValue* Счетчик обязан вернуть значение большее заданного. По умолчанию 0.

    **Внимание!** В текущей модели возможно сколько угодно генераций новых значений
внутри транзакции, но учтено будет только подтвержденное с помощью commit().
Поэтому остерегайтесь использовать значения счетчика до того как завершите транзакцию.

3. *public function getOne( int $baseValue, float $timeout, int $sleep )*.

    Получение следующего значения счетчика без явного использования транзакции.
Весь механизм транзакции ДОЛЖЕН быть реализован внутри метода.

    Возвращает новое значение при успешном завершении, иначе возвращает FALSE.

    * *$baseValue* Счетчик обязан вернуть значение большее заданного. По умолчанию 0.
    * *$timeout* Сколько секунд пытаться перейти в режим транзакции. По умолчанию 0 (только одна поптытка).
    * *$sleep* Сколько микросекунд ожидать между попытками перейти в режим транзакции. По умолчанию 1000.

4. *public function lock()*.

    Переход в режим транзакции.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.

5. *public function locked()*.

    Возвращает TRUE если счетчик в режиме транзакции, иначе возвращает FALSE.

6. *public function rollback()*.

    Завершает транзакцию и откатывает счетчик к предыдущему состоянию.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.

7. *public function setTo( int $value, float $timeout, int $sleep)*.

    Явно установить значение счетчика без явного использования транзакции.
Весь механизм транзакции ДОЛЖЕН быть реализован внутри метода.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.

    * *$value* Новое значение счетчика.
    * *$timeout* Сколько секунд пытаться перейти в режим транзакции. По умолчанию 0 (только одна поптытка).
    * *$sleep* Сколько микросекунд ожидать между попытками перейти в режим транзакции. По умолчанию 1000.

8. *public function value()*.

    В режиме транзакции возвращет NULL если значение еще не было сгенерированно
или значение счетчика. Если счетчик не в режиме транзакции возвращает FALSE.

9. *public function unlock()*.

    "Насильно" отменяет режим транзакции.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.


### Класс Seotils\Utilites\Counters\OnetimeCounter

Простейший счетчик, который увеличивается только в пределах одного потока.
Каждый раз как вы запускаете скрипт, он обнуляется. Однако, в пределах выполнения
приложения генерирует уникальные значения для всех классов потомков. В качестве хранилища
текущего значения счетчика используется *protected static* свойство *OnetimeCounter::$counter*.

### Класс Seotils\Utilites\Counters\FileCounter

Счетчик, использующий в качестве хранилища текущего значения счетчика файл.
Защищен в пределах одной физической машины. Не зависит от количества запущенных потоков.

### Класс Seotils\Utilites\Counters\CacheCounter

Счетчик, использующий в качестве хранилища текущего значения счетчика кеш.
Защищен в пределах одной физической машины. Не зависит от количества запущенных потоков.

**Внимание!** Кеш, который вы будете использовать в качестве хранилища, должен
удовлетворять ["PSR-6 Caching Interface"] (http://www.php-fig.org/psr/psr-6/).
Например, следущие реализации кеша
[psr/cache-implementation] (https://packagist.org/providers/psr/cache-implementation).

### Ваш собственный счетчик

Для безопасной замены счетчиков и унификации кода ваш собственный счетчик должен
реализовывать интерфейс *Seotils\Utilites\Counters\Interfaces\ICounter*.

Однако, самый простой путь - наследовать свой класс от класса *Seotils\Utilites\Counters\BaseCounter*
и реализовать следующие функции:

1. *public function lock()*. Необходимо реализовать.

2. *public function locked()*.  Необходимо реализовать.

3. *public function unlock()*.  Необходимо реализовать.

4. *protected function save( bool $state, int $value)*.  Необходимо реализовать.

    Фунция записывает в хранилище значение счетчика и его статус.

    Возвращает TRUE при успешном завершении, иначе возвращает FALSE.

    * *$status* Находится ли счетчик в режиме транзакции.
    * *$value* Значение счетчика.

5. *protected function reset()*. Возможно надо будет переопределить.
Не забудьте вызвать *parent::reset();* при переопределении этого метода.

    Фунция вызывается после завершения транзакции. Предназначена обеспечивать корректную
работу методов связанными с транзакциями при многократном использовании счетчика.

Все эти функции были вынесены из базового класса, так как зависят только от способа
хранения значения счетчика.

Особо обратите внимание на свойство класса *$oldValue* - старое значение счетчика.
Его НЕОБХОДИМО инициализировать в функции *lock()*.

### Примеры

Создание:

```php

    use Seotils\Utilites\Counters\OnetimeCounter;
    use Seotils\Utilites\Counters\FileCounter;
    use Seotils\Utilites\Counters\CacheCounter;

    $onetimeCounter = new OnetimeCounter();

    $fileCounter = new FileCounter(
        $someFolder . '/FileCounter.dat' // Файл для хранения значения счетчика
    );

    $cacheCounter = new CacheCounter(
        $myPsr6Cache,   // Кеш, удовлетаоряющий psr/cache
        'MyCashCounter' // Префикс для ключей кеша
    );

```

*OnetimeCounter* можно использовать, например, для индексирования наборов чего либо,
чтобы не реализовывать механизмы проверки/запоминания индекса. А потом, при переходе к более
сложной модели индексирования, можно легко, и без рефакторинга кода, заменить
*OnetimeCounter* на другой счетчик.

```php

    class A {

      private static $classes = [];

      private static $counterInstance = null;

      private static function counter() {
        if( ! self::$counterInstance ) {
          self::$counterInstance = new OnetimeCounter();
        }
        return self::$counterInstance;
      }

      public static function factory( $class ) {
        $id = self::counter()->getOne();
        return self::$clases [$id] = new $class( $id );
      }

    }

```

*FileCounter* и *CacheCounter* различаются только способом хранения, поэтому рассмотрим их вместе.

Эти счетчики независимы от потоков исполнения и сохраняют свои значения в перерывах между исполнением кода.

```php

    function foreground( $data ) {
      $dataToCache = [
        'id' => $myCounter->getOne(),
        'data' => $data,
      ];
      moveToCache( $dataToCache );
    }

    function background( $data ) {
      $dataToDatabase = [
        'id' => $myCounter->getOne(),
        'data' => $data,
      ];
      moveToDatabase( $dataToDatabase );
    }

    function dumpCache() {
      $dataToDatabase = getFromCache();
      moveToDatabase( $dataToDatabase );
    }

```

В этом примере мы видим, что у нас есть функция *foreground( $data )* , которая
помещает какие-то данные в кеш, например для ускорения времени отклика сайта.
А так же имеются функции *background( $data )*, которая пишет схожие данные в базу данных,
и *dumpCache()*, перемещающая данные из кеша тоже в базу данных.

Итак, благодаря счетчику, мы уверены, что ключевые поля данных *id* не будут конфликтовать между
собой и нам не надо постоянно дергать базу для сверки этого поля, а так же нет нужды
писать взаимные локировки, чтобы случайно не использовать одно и тоже значение первичного ключа.

## Генератор уникальных значений

### Интерфейс

### Класс Seotils\Utilites\Counters\UniqueGenerator
